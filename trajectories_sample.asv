% 1) 圆台参数
n_circles = 100;
z_max     = 80;    z_min     = 60;
diam_max  = 30;    diam_min  = 10;

z_lin   = linspace(z_max, z_min, n_circles);
r_lin   = linspace(diam_min/2, diam_max/2, n_circles);
r_fun   = @(zz) interp1(z_lin, r_lin, zz, 'linear', 'extrap');

% 2) 先算并画圆台表面
n_surf_z = 100;  n_surf_t = 200;
Zs = linspace(z_max, z_min, n_surf_z);
Ts = linspace(0, 2*pi, n_surf_t);
[ZZ,TT] = meshgrid(Zs,Ts);
Xs = r_fun(ZZ).*cos(TT);
Ys = r_fun(ZZ).*sin(TT);

figure; hold on; grid on; axis equal; view(3);
surf(Xs,Ys,ZZ,'FaceAlpha',0.15,'EdgeColor','none');
xlabel('X (mm)'); ylabel('Y (mm)'); zlabel('Z (mm)');
title('Continuous frustum & random trajectories');

% 2) 轨迹采样参数
step_len = 1;       n_steps = 50;

% 3) 容器：cell 数组，每元 struct 含 p,q,angle
trajectories = cell(n_circles,1);

colors = lines(n_circles);
figure; hold on; grid on; axis equal; view(3);
title('Trajectories with q & angle computation');

for idx = 1:n_circles
    % ---------- 3.1 生成随机轨迹 p ----------
    z0   = z_lin(idx);
    P    = zeros(n_steps+1,3);
    P(1,:) = [0,0,z0];                      % 起点

    for k = 2:n_steps+1
        while true
            dir  = randn(1,3); dir = dir/norm(dir);
            cand = P(k-1,:) + step_len*dir;
            if cand(3)<z_min || cand(3)>z_max, continue; end
            if hypot(cand(1),cand(2)) <= r_fun(cand(3)), break; end
        end
        P(k,:) = cand;
    end

    % ---------- 3.2 逐点求 q ----------
    Q = zeros(size(P));           % (n_steps+1)×3
    for k = 1:size(P,1)
        q = Constant_curvature(P(k,:)');    % 3×1
        Q(k,:) = q';
    end

    % ---------- 3.3 逐点求 angle ----------
    Ang = zeros(size(P));         % (n_steps+1)×3
    for k = 1:size(P,1)
        angles1 = find_angle_for_length(Q(k,1));
        angles2 = find_angle_for_length(Q(k,2));
        angles3 = find_angle_for_length(Q(k,3));
        % 这里只取每个数组的第一个根；如需全部保存，改成 cell
        Ang(k,1) = angles1(1);
        Ang(k,2) = angles2(1);
        Ang(k,3) = angles3(1);
    end

    % ---------- 3.3b 计算 angle 的增量 ----------
    % Δangle(i,:) = Ang(i+1,:) − Ang(i,:)，结果尺寸 50×3
    dAng = diff(Ang, 1, 1);        % 50×3

    % ---------- 3.4 打包 ----------
    trajectories{idx} = struct( ...
        'p',      P,      ...      % 51×3
        'q',      Q,      ...      % 51×3
        'angle',  Ang,    ...      % 51×3
        'dAngle', dAng );          % 50×3

    % ---------- 3.5 绘制轨迹 ----------
    plot3(P(:,1),P(:,2),P(:,3),'-','Color',colors(idx,:));
end
hold off;

% 4) 访问示例 —— 取第 10 条
sel = 10;
traj = trajectories{sel};
fprintf('Trajectory %d: first point p = [%g %g %g]\n', sel, traj.p(1,:));
fprintf('Corresponding first q = [%g %g %g], angles = [%g %g %g]\n', ...
        traj.q(1,:), traj.angle(1,:));